## Just like the examples provided, makeCacheMatrix creates a matrix and 4 functions. cacheSolves check cache/calculate the inverse and
## also check the cache.

rm(list=ls()) ##clear environment
## makeCacheMatrix is the first part. It returns a special type of matrix that carries also a list of four functions and cache the inverse matrix 

makeCacheMatrix <- function(x = matrix()) {             ## Object 1 is "x"
        inv <- NULL                                     ## Object 2 is "inv"
        setmat <- function(y) {                         ## Setmat() is the first function defined in the "makeCacheMatrix" environment
                x <<- y                                 ## Since x is not in setmat(), y is defined as the "x" in the parent environment 
                ##       "makeCacheMatrix"
                inv <<- NULL                            ## Empty the cache every time a new "makeCacheMatrix" is called to maka new vector
        }                       
        getmat <- function() {x}                        ## Getmat() is the second function in the "makeCacheMatrix" environment
        setinv <- function(inverse) {inv <<- inverse}   ## Setin(inverse) is the third function in the "makeCacheMatrix" environment
        getinv <- function() {inv}                      ## Getinv() is the forth function in the "makeCacheMatrix" environment
        list(setmat = setmat, getmat = getmat,          ## Bind the four functions with names so the atomic 
             ##       operator "$" can be called in "cacheSolve"                
             setinv = setinv,
             getinv = getinv)
}

## Test makeCacheMatrix

RNGversion("3.5.1")                                     ## Set the RNG version 
set.seed(69420)                                         ## Set the seed
a<-matrix(sample(1:100,size = 16),nrow=4)               ## Generate matrix "a", which is a 4x4 matrix with numbers from {1:100}
b<-makeCacheMatrix(a)                                   ## Convert matrix "a" into the special type matrix "b" generated by 
##       "makeCacheMatrix"
b$getmat()                                              ## Print("b") see if the values of "a" is still there
b                                                       ## See the list of four functions that comes with the special matrix


## cacheSolve only works with a matrix generated by makeCacheMatrix.It checks the cache, if its empty then calculate and store a new inverse mat

cacheSolve <- function(x, ...) {                                
        inv <- x$getinv()                               ## Lexical Scoping allows the use of $ vector to call the getinv function 
        if(!is.null(inv)) {                             ## Check if the cache is full (value != NULL), then just return the cache
                message("getting cached data")                  
                return(inv)
        }
        data <- x$getmat()                              ## If the cache is empty, meaning a new matrix was made with makeCacheMatrix,
        inv <- solve(data, ...)                         ##      then we solve the inverse matrix 
        x$setinv(inv)                                   ## Then store the solved matrix in the cache of makeCacheMatrix
        inv                                             ## print the inverse matrix
}

## Test the cachSolve function

cacheSolve(b)                                            ## Use the test function constructed above to make a makeCacheMatrix matrix
## Call the same function again to see if the cache is used. Also multiply the 
##      inverted matrix with the makeCacheMatrix to see if it equals to I matrix
round(cacheSolve(b) %*% a, digits = 3)
